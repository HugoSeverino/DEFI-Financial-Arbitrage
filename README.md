# üöÄ DEFI Financial Arbitrage

Un syst√®me d'arbitrage financier DeFi automatis√© qui surveille et analyse les opportunit√©s d'arbitrage entre diff√©rentes plateformes de trading d√©centralis√©es (DEX) sur le r√©seau Base.

## üìã Table des mati√®res

- [Vue d'ensemble](#vue-densemble)
- [Flux d'ex√©cution chronologique](#flux-dex√©cution-chronologique)
- [D√©tail des fonctions Python](#d√©tail-des-fonctions-python)
- [Architecture](#architecture)
- [Installation](#installation)
- [Configuration](#configuration)
- [Utilisation](#utilisation)
- [Structure du projet](#structure-du-projet)
- [API et d√©pendances](#api-et-d√©pendances)
- [Base de donn√©es](#base-de-donn√©es)
- [DEX support√©s](#dex-support√©s)
- [Exemples d'utilisation](#exemples-dutilisation)
- [D√©pannage](#d√©pannage)
- [Contribution](#contribution)
- [Licence](#licence)

## üéØ Vue d'ensemble

Ce projet est un syst√®me sophistiqu√© d'arbitrage DeFi qui :

- **Surveille en temps r√©el** les √©v√©nements de cr√©ation de pools sur les DEX majeurs
- **Collecte et stocke** les donn√©es de pools dans une base de donn√©es MySQL
- **Analyse les opportunit√©s d'arbitrage** entre Uniswap V2/V3 et SushiSwap V2/V3
- **Filtre les tokens orphelins** pour optimiser les performances
- **Met √† jour automatiquement** les r√©serves et informations des pools

## ‚è∞ Flux d'ex√©cution chronologique

Le programme suit un processus s√©quentiel pr√©cis en 6 phases principales :

### üîß **Phase 1 : Initialisation et Configuration**
```python
# 1.1 Chargement des variables d'environnement
load_dotenv()
API_Keys = os.getenv('Base_API')

# 1.2 Connexion √† la blockchain Base
web3 = Web3(Web3.HTTPProvider(f"https://base-mainnet.g.alchemy.com/v2/{API_Keys}"))

# 1.3 D√©finition des adresses des factories DEX
UniswapV3_factory = "0x33128a8fC17869897dcE68Ed026d694621f6FDfD"
SushiswapV3_factory = "0xc35DADB65012eC5796536bD9864eD8773aBc74C4"
SushiswapV2_factory = "0x71524B4f93c58fcbF659783284E38825f0622859"
UniswapV2_factory = "0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6"
```

### üì° **Phase 2 : Collecte des √©v√©nements de cr√©ation de pools**
Le syst√®me parcourt la blockchain par blocs pour r√©cup√©rer tous les √©v√©nements de cr√©ation de pools :

```python
# 2.1 R√©cup√©ration des pools Uniswap V3
Fetch_EventsPairV3(web3, UniswapV3_factory, "Uniswap").IterateOverBlocks()

# 2.2 R√©cup√©ration des pools SushiSwap V3  
Fetch_EventsPairV3(web3, SushiswapV3_factory, "Sushiswap").IterateOverBlocks()

# 2.3 R√©cup√©ration des pools SushiSwap V2
Fetch_EventsPairV2(web3, SushiswapV2_factory, "Sushiswap").IterateOverBlocks()

# 2.4 R√©cup√©ration des pools Uniswap V2
Fetch_EventsPairV2(web3, UniswapV2_factory, "Uniswap").IterateOverBlocks()
```

**D√©tail du processus de collecte :**
- Le syst√®me v√©rifie d'abord le dernier bloc trait√© dans les fichiers JSON
- Il parcourt la blockchain par tranches de 50k-60k blocs pour √©viter les limites API
- Pour chaque √©v√©nement `PoolCreated`/`PairCreated`, il extrait :
  - Adresse du pool
  - Token0 et Token1
  - Frais de trading
  - Num√©ro de bloc de cr√©ation
  - Tick spacing (pour V3)
- Les donn√©es sont sauvegard√©es dans des fichiers JSON temporaires

### üóÑÔ∏è **Phase 3 : Initialisation de la base de donn√©es**
```python
# 3.1 Cr√©ation de la base de donn√©es et des tables
SQL_Init()  # Cr√©e la DB 'mainet' et les tables PoolList/TokenList
```

**Tables cr√©√©es :**
- `PoolList` : Stockage des informations des pools
- `TokenList` : Stockage des informations des tokens

### üíæ **Phase 4 : Insertion des donn√©es dans MySQL**
Le syst√®me charge les donn√©es JSON et les ins√®re dans la base de donn√©es :

```python
# 4.1 Chargement et insertion Uniswap V3
Uniswapv3_ListPools = JsonFile_Data_ListePools.ReturnJsonAsPythonReadable("JSON/UniswapV3.json")
SQL_Pools().Update_Database(Uniswapv3_ListPools, 3)

# 4.2 Chargement et insertion SushiSwap V3
Sushiswapv3_ListPools = JsonFile_Data_ListePools.ReturnJsonAsPythonReadable("JSON/SushiswapV3.json")
SQL_Pools().Update_Database(Sushiswapv3_ListPools, 3)

# 4.3 Chargement et insertion Uniswap V2
Uniswapv2_ListPools = JsonFile_Data_ListePools.ReturnJsonAsPythonReadable("JSON/UniswapV2.json")
SQL_Pools().Update_Database(Uniswapv2_ListPools, 2)

# 4.4 Chargement et insertion SushiSwap V2
Sushiswapv2_ListPools = JsonFile_Data_ListePools.ReturnJsonAsPythonReadable("JSON/SushiswapV2.json")
SQL_Pools().Update_Database(Sushiswapv2_ListPools, 2)
```

**Processus d'insertion :**
- Pour chaque pool, insertion des informations dans `PoolList`
- Insertion automatique des tokens associ√©s dans `TokenList`
- Gestion des doublons avec `INSERT IGNORE`

### üìä **Phase 5 : Statistiques et affichage**
```python
# 5.1 Comptage des donn√©es collect√©es
Number_Of_Pools = SQL_Pools().Count()
Number_Of_Tokens = SQL_Token().Count()

print(f'We have {Number_Of_Pools} Pools and {Number_Of_Tokens} Token in our Mysql Database')
```

### üßπ **Phase 6 : Nettoyage et optimisation**
Cette phase optimise les donn√©es pour l'arbitrage :

```python
# 6.1 Filtrage des tokens orphelins
Number_Of_Pools_no_Orphelin = SQL_Pools().Update_Orphelin()
Number_Of_Tokens_no_Orphelin = SQL_Token().Update_Orphelin()

print(f'After excluding orphelins we have now {Number_Of_Pools_no_Orphelin} Pools and {Number_Of_Tokens_no_Orphelin} Tokens')

# 6.2 Validation des tokens ERC20
SQL_Token().Update_Error(web3)  # V√©rifie les symboles et d√©cimales

# 6.3 Mise √† jour des r√©serves des pools
SQL_Pools().Update_Pools_Data(web3)  # R√©cup√®re les r√©serves actuelles
```

**D√©tail du processus d'optimisation :**

#### 6.1 Filtrage des orphelins
- **Logique** : Un token orphelin n'appara√Æt que dans un seul pool
- **Action** : Marquer comme `orphelin = true` les tokens/pools non utilisables pour l'arbitrage
- **Raison** : L'arbitrage n√©cessite au moins 2 pools pour le m√™me token

#### 6.2 Validation des tokens
- **Processus** : Pour chaque token non-orphelin, appeler les fonctions ERC20
- **V√©rifications** :
  - `symbol()` : R√©cup√©ration du symbole du token
  - `decimals()` : R√©cup√©ration du nombre de d√©cimales
- **Gestion d'erreur** : Marquer `error = true` si le token n'est pas valide

#### 6.3 Mise √† jour des r√©serves
- **Objectif** : R√©cup√©rer les r√©serves actuelles de chaque pool
- **Donn√©es collect√©es** :
  - R√©serves token0 et token1
  - Prix actuels (t0_t1, t1_t0)
  - Liquidit√© totale
  - Tick actuel (pour V3)

## üîß D√©tail des fonctions Python

### üì° **Module Fetch_EventsPairV3**

#### `__init__(self, web3, Factory_adress, App)`
**Ce que fait cette fonction :**
- Initialise l'instance pour r√©cup√©rer les √©v√©nements de cr√©ation de pools V3
- Configure l'√©v√©nement `PoolCreated` √† surveiller
- Charge l'ABI du factory V3 depuis `JSON/PairV3.json`
- D√©termine le bloc de d√©part en lisant le dernier bloc trait√© dans le fichier JSON correspondant
- Cr√©e une instance de contrat Web3 pour interagir avec le factory
- R√©cup√®re le num√©ro du bloc actuel de la blockchain

**Param√®tres :**
- `web3` : Instance Web3 connect√©e √† la blockchain
- `Factory_adress` : Adresse du contrat factory (ex: Uniswap V3)
- `App` : Nom de l'application (ex: "Uniswap", "Sushiswap")

#### `fetch_events(self, event, argument_filters, from_block, to_block, address, topics)`
**Ce que fait cette fonction :**
- R√©cup√®re les logs d'√©v√©nements depuis la blockchain pour une plage de blocs donn√©e
- Construit les param√®tres de filtre pour l'API JSON-RPC
- Appelle `web3.eth.get_logs()` pour r√©cup√©rer les logs bruts
- D√©code chaque log en utilisant l'ABI de l'√©v√©nement
- Retourne un g√©n√©rateur qui yield chaque √©v√©nement d√©cod√©

**Processus interne :**
1. Valide que `from_block` est fourni
2. R√©cup√®re l'ABI de l'√©v√©nement
3. Construit les param√®tres de filtre avec `construct_event_filter_params`
4. Appelle l'API blockchain pour r√©cup√©rer les logs
5. D√©code chaque log avec `get_event_data`

#### `IterateOverBlocks(self)`
**Ce que fait cette fonction :**
- Parcourt la blockchain par tranches de 60k blocs pour √©viter les limites API
- Pour chaque tranche, appelle `fetch_events()` pour r√©cup√©rer les √©v√©nements
- Extrait les informations de chaque pool cr√©√©
- Sauvegarde les donn√©es dans un fichier JSON

**Processus d√©taill√© :**
1. Calcule la plage de blocs √† traiter (du dernier bloc trait√© au bloc actuel)
2. Divise en tranches de 60k blocs maximum
3. Pour chaque tranche :
   - Appelle `fetch_events()` pour r√©cup√©rer les √©v√©nements
   - Extrait pour chaque √©v√©nement :
     - `pool` : Adresse du pool cr√©√©
     - `token0` : Adresse du premier token
     - `token1` : Adresse du second token
     - `fee` : Frais de trading du pool
     - `block` : Num√©ro de bloc de cr√©ation
     - `tickSpacing` : Espacement des ticks (V3 uniquement)
4. Sauvegarde les donn√©es dans `JSON/{App}V3.json`

### üì° **Module Fetch_EventsPairV2**

#### `__init__(self, web3, Factory_adress, App)`
**Ce que fait cette fonction :**
- Identique √† V3 mais pour les pools V2
- Configure l'√©v√©nement `PairCreated` au lieu de `PoolCreated`
- Charge l'ABI V2 depuis `JSON/PairV2.json`

#### `IterateOverBlocks(self)`
**Ce que fait cette fonction :**
- Similaire √† V3 mais avec des tranches de 50k blocs
- Extrait les m√™mes informations sauf `tickSpacing`
- Fixe les frais √† 3000 (0.3%) pour tous les pools V2
- Sauvegarde dans `JSON/{App}V2.json`

### üìÑ **Module JsonFile_Data_ListePools**

#### `ReturnJsonAsPythonReadable(self)`
**Ce que fait cette fonction :**
- Ouvre un fichier JSON et le charge en m√©moire
- Retourne le contenu sous forme de dictionnaire Python

#### `ReturnLastItemBlock(self)`
**Ce que fait cette fonction :**
- Ouvre le fichier JSON correspondant
- R√©cup√®re le num√©ro de bloc du dernier √©l√©ment
- Retourne 0 si le fichier n'existe pas ou est vide
- Utilis√© pour reprendre la collecte depuis le bon bloc

#### `AddDatainJson(self, data)`
**Ce que fait cette fonction :**
- Charge les donn√©es existantes du fichier JSON
- Ajoute les nouvelles donn√©es √† la liste existante
- Sauvegarde le tout dans le fichier JSON
- G√®re le cas o√π le fichier n'existe pas (cr√©e une liste vide)

### üóÑÔ∏è **Module SQL_Init**

#### `__init__(self)`
**Ce que fait cette fonction :**
- Se connecte √† MySQL avec les credentials du fichier `.env`
- Appelle `CreateDatabase()` pour cr√©er la base de donn√©es
- Se reconnecte √† la base de donn√©es cr√©√©e
- Appelle `CreateTable()` pour cr√©er les tables
- Ferme la connexion

#### `CreateDatabase(self)`
**Ce que fait cette fonction :**
- Ex√©cute `CREATE DATABASE mainet`
- G√®re l'erreur si la base existe d√©j√† (erreur 1007)
- Affiche un message de confirmation ou d'erreur

#### `CreateTable(self)`
**Ce que fait cette fonction :**
- Cr√©e la table `PoolList` avec tous les champs n√©cessaires
- Cr√©e la table `TokenList` avec les informations des tokens
- Utilise `CREATE TABLE IF NOT EXISTS` pour √©viter les erreurs

### üíæ **Module SQL_Pools**

#### `__init__(self)`
**Ce que fait cette fonction :**
- Se connecte √† la base de donn√©es MySQL `mainet`
- Utilise les credentials du fichier `.env`

#### `Update_Database(self, PoolsList, version)`
**Ce que fait cette fonction :**
- Parcourt la liste des pools en ordre inverse (du plus r√©cent au plus ancien)
- Pour chaque pool :
  - Extrait les informations (adresse, tokens, frais, bloc, version)
  - Ins√®re dans `PoolList` avec ou sans `tickSpacing` selon la version
  - Appelle `SQL_Token.Update_Database()` pour ins√©rer les tokens
- G√®re les erreurs de doublons (erreur 1062)
- Ferme la connexion √† la fin

#### `Count(self)`
**Ce que fait cette fonction :**
- Ex√©cute `SELECT COUNT(*) FROM PoolList`
- Retourne le nombre total de pools en base
- Ferme la connexion

#### `Update_Orphelin(self)`
**Ce que fait cette fonction :**
- Identifie les tokens qui n'apparaissent que dans un seul pool
- Marque comme `orphelin = true` les pools contenant ces tokens
- Marque comme `orphelin = false` les pools avec des tokens valides
- Retourne le nombre de pools non-orphelins

**Logique SQL :**
1. Trouve tous les tokens qui n'apparaissent qu'une fois
2. Marque comme orphelins les pools contenant ces tokens
3. Marque comme valides les pools avec des tokens multiples

#### `Update_Pools_Data(self, web3)`
**Ce que fait cette fonction :**
- R√©cup√®re le num√©ro de bloc actuel
- Pr√©pare la mise √† jour des r√©serves des pools
- (Fonction incompl√®te dans le code actuel)

### ü™ô **Module SQL_Token**

#### `__init__(self)`
**Ce que fait cette fonction :**
- Se connecte √† la base de donn√©es MySQL `mainet`

#### `Update_Database(self, token0, token1)`
**Ce que fait cette fonction :**
- Ins√®re les deux tokens dans `TokenList` avec `INSERT IGNORE`
- √âvite les doublons automatiquement
- G√®re les erreurs de contrainte d'unicit√©

#### `Count(self)`
**Ce que fait cette fonction :**
- Ex√©cute `SELECT COUNT(*) FROM TokenList`
- Retourne le nombre total de tokens en base

#### `Update_Orphelin(self)`
**Ce que fait cette fonction :**
- Identique √† `SQL_Pools.Update_Orphelin()` mais pour la table `TokenList`
- Marque comme orphelins les tokens qui n'apparaissent qu'une fois
- Retourne le nombre de tokens non-orphelins

#### `Update_Error(self, web3)`
**Ce que fait cette fonction :**
- R√©cup√®re tous les tokens non-orphelins qui n'ont pas encore √©t√© valid√©s
- Pour chaque token :
  - Cr√©e une instance de contrat ERC20
  - Appelle `symbol()` et `decimals()`
  - Met √† jour la base avec les informations r√©cup√©r√©es
  - Marque `error = true` si l'appel √©choue
- G√®re les exceptions et continue le traitement

## üîÑ Diagramme de flux chronologique

```mermaid
graph TD
    A[üöÄ D√©marrage] --> B[‚öôÔ∏è Phase 1: Initialisation]
    B --> C[üì° Phase 2: Collecte √©v√©nements]
    C --> D[üóÑÔ∏è Phase 3: Init Base de donn√©es]
    D --> E[üíæ Phase 4: Insertion donn√©es]
    E --> F[üìä Phase 5: Statistiques]
    F --> G[üßπ Phase 6: Optimisation]
    
    C --> C1[Uniswap V3]
    C --> C2[SushiSwap V3]
    C --> C3[Uniswap V2]
    C --> C4[SushiSwap V2]
    
    C1 --> C5[üìÑ Sauvegarde JSON]
    C2 --> C5
    C3 --> C5
    C4 --> C5
    
    E --> E1[Chargement JSON]
    E1 --> E2[Insertion PoolList]
    E2 --> E3[Insertion TokenList]
    
    G --> G1[üîç Filtrage orphelins]
    G1 --> G2[‚úÖ Validation tokens]
    G2 --> G3[üìà Mise √† jour r√©serves]
    
    G3 --> H[‚úÖ Termin√©]
```

## üèóÔ∏è Architecture

```
DEFI-Financial-Arbitrage/
‚îú‚îÄ‚îÄ code/
‚îÇ   ‚îú‚îÄ‚îÄ __main__.py                 # Point d'entr√©e principal
‚îÇ   ‚îú‚îÄ‚îÄ Functions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Events/                 # Gestion des √©v√©nements blockchain
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Fetch_EventsPairV2.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Fetch_EventsPairV3.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ JSON/                   # Gestion des fichiers JSON
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ JsonFile_ABI_V2.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ JsonFile_ABI_V3.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ JsonFile_Data_ListePools.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SQL/                    # Gestion de la base de donn√©es
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SQL_Init.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SQL_Pools.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SQL_Token.py
‚îÇ   ‚îî‚îÄ‚îÄ JSON/                       # Fichiers de donn√©es et ABI
‚îÇ       ‚îú‚îÄ‚îÄ UniswapV2.json
‚îÇ       ‚îú‚îÄ‚îÄ UniswapV3.json
‚îÇ       ‚îú‚îÄ‚îÄ SushiswapV2.json
‚îÇ       ‚îú‚îÄ‚îÄ SushiswapV3.json
‚îÇ       ‚îú‚îÄ‚îÄ PairV2.json
‚îÇ       ‚îú‚îÄ‚îÄ PairV3.json
‚îÇ       ‚îî‚îÄ‚îÄ ERC20.json
‚îú‚îÄ‚îÄ env/                           # Environnement virtuel Python
‚îú‚îÄ‚îÄ env2/                          # Environnement virtuel alternatif
‚îú‚îÄ‚îÄ fctparcourblock.py            # Script de parcours de blocs
‚îú‚îÄ‚îÄ test2.py                       # Script de test
‚îú‚îÄ‚îÄ test3.py                       # Script de test avanc√©
‚îú‚îÄ‚îÄ requirements.txt               # D√©pendances Python
‚îî‚îÄ‚îÄ README.md                      # Ce fichier
```

## üöÄ Installation

### Pr√©requis
- Python 3.8 ou sup√©rieur
- MySQL Server
- Compte API Alchemy/Infura/QuickNode

### √âtapes d'installation

1. **Cloner le repository**
```bash
git clone <url-du-repository>
cd DEFI-Financial-Arbitrage
```

2. **Cr√©er un environnement virtuel**
```bash
python -m venv env
# Sur Windows
env\Scripts\activate
# Sur Linux/Mac
source env/bin/activate
```

3. **Installer les d√©pendances**
```bash
pip install -r requirements.txt
```

4. **Configurer MySQL**
```sql
CREATE DATABASE mainet;
CREATE USER 'arbitrage_user'@'localhost' IDENTIFIED BY 'votre_mot_de_passe';
GRANT ALL PRIVILEGES ON mainet.* TO 'arbitrage_user'@'localhost';
FLUSH PRIVILEGES;
```

## ‚öôÔ∏è Configuration

### Variables d'environnement

Cr√©ez un fichier `.env` √† la racine du projet :

```env
# API Keys
Base_API=your_alchemy_base_api_key
Infura_API=your_infura_api_key
Quicknode_API=your_quicknode_api_key

# Base de donn√©es
SQL_Password=your_mysql_password
```

### Adresses des contrats

Le syst√®me surveille les factories suivantes sur Base :

- **Uniswap V3 Factory**: `0x33128a8fC17869897dcE68Ed026d694621f6FDfD`
- **SushiSwap V3 Factory**: `0xc35DADB65012eC5796536bD9864eD8773aBc74C4`
- **SushiSwap V2 Factory**: `0x71524B4f93c58fcbF659783284E38825f0622859`
- **Uniswap V2 Factory**: `0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6`

## üéÆ Utilisation

### Ex√©cution principale

```bash
python -m code
```

### Scripts de test

```bash
# Test de parcours de blocs
python fctparcourblock.py

# Test de surveillance d'adresses sp√©cifiques
python test2.py

# Test de surveillance de pools Uniswap V2
python test3.py
```

## üìÅ Structure du projet

### Modules principaux

#### `Fetch_EventsPairV2/V3`
- R√©cup√®re les √©v√©nements de cr√©ation de pools
- G√®re les limitations API (traitement par blocs)
- Support des versions V2 et V3

#### `SQL_Pools`
- Gestion des pools en base de donn√©es
- Filtrage des tokens orphelins
- Mise √† jour des r√©serves

#### `SQL_Token`
- Gestion des tokens
- Validation des adresses
- Mise √† jour des informations

#### `JsonFile_Data_ListePools`
- Gestion des fichiers JSON
- Persistance des donn√©es de pools
- R√©cup√©ration des derniers blocs trait√©s

## üîå API et d√©pendances

### D√©pendances principales
- **web3**: Interface avec la blockchain Ethereum
- **mysql-connector-python**: Connexion √† MySQL
- **python-dotenv**: Gestion des variables d'environnement
- **eth-abi**: D√©codage des donn√©es ABI
- **aiohttp**: Requ√™tes HTTP asynchrones

### Fournisseurs API support√©s
- Alchemy (recommand√© pour Base)
- Infura
- QuickNode

## üóÑÔ∏è Base de donn√©es

### Tables principales

#### `PoolList`
```sql
CREATE TABLE PoolList (
    pool VARCHAR(255) PRIMARY KEY,
    token0 VARCHAR(255),
    token1 VARCHAR(255),
    fee integer,
    reserve0 float8,
    reserve1 float8,
    tickspacing integer,
    SQRTX96 integer,
    tick integer,
    liquidity integer,
    block_creation integer,
    block_last_use integer,
    version integer,
    orphelin boolean,
    block_last_refresh integer,
    t0_t1 float8,
    t1_t0 float8
);
```

#### `TokenList`
```sql
CREATE TABLE TokenList (
    adrr VARCHAR(255) PRIMARY KEY,
    symb VARCHAR(255),
    deci integer,
    error boolean,
    orphelin boolean
);
```

## üè™ DEX support√©s

| DEX | Version | Factory Address | Status |
|-----|---------|----------------|--------|
| Uniswap | V2 | `0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6` | ‚úÖ |
| Uniswap | V3 | `0x33128a8fC17869897dcE68Ed026d694621f6FDfD` | ‚úÖ |
| SushiSwap | V2 | `0x71524B4f93c58fcbF659783284E38825f0622859` | ‚úÖ |
| SushiSwap | V3 | `0xc35DADB65012eC5796536bD9864eD8773aBc74C4` | ‚úÖ |

## üìä Exemples d'utilisation

### Surveillance d'un pool sp√©cifique

```python
from web3 import Web3
from code.Functions.Events import Fetch_EventsPairV3

# Connexion √† la blockchain
web3 = Web3(Web3.HTTPProvider("https://base-mainnet.g.alchemy.com/v2/YOUR_API_KEY"))

# Surveillance des pools Uniswap V3
uniswap_factory = "0x33128a8fC17869897dcE68Ed026d694621f6FDfD"
fetcher = Fetch_EventsPairV3(web3, uniswap_factory, "Uniswap")
fetcher.IterateOverBlocks()
```

### Analyse des donn√©es de pools

```python
from code.Functions.SQL import SQL_Pools

# Compter les pools
pools_count = SQL_Pools().Count()
print(f"Nombre total de pools: {pools_count}")

# Filtrer les orphelins
valid_pools = SQL_Pools().Update_Orphelin()
print(f"Pools valides apr√®s filtrage: {valid_pools}")
```

## üîß D√©pannage

### Probl√®mes courants

#### Erreur de connexion API
```
Solution: V√©rifiez votre cl√© API et les limites de taux
```

#### Erreur de base de donn√©es
```
Solution: V√©rifiez les credentials MySQL et la connexion
```

#### Limite de blocs atteinte
```
Solution: Le syst√®me traite automatiquement par blocs de 50k-60k
```

### Logs et monitoring

Le syst√®me affiche des logs d√©taill√©s :
- Nombre d'√©v√©nements r√©cup√©r√©s par bloc
- Progression du traitement
- Erreurs et avertissements
- Statistiques des pools et tokens

## ü§ù Contribution

1. Fork le projet
2. Cr√©ez une branche feature (`git checkout -b feature/AmazingFeature`)
3. Commit vos changements (`git commit -m 'Add some AmazingFeature'`)
4. Push vers la branche (`git push origin feature/AmazingFeature`)
5. Ouvrez une Pull Request

## üìÑ Licence

Ce projet est sous licence MIT. Voir le fichier `LICENSE` pour plus de d√©tails.

## ‚ö†Ô∏è Avertissements

- **Risques financiers**: L'arbitrage DeFi comporte des risques financiers importants
- **Volatilit√©**: Les prix des crypto-monnaies sont tr√®s volatils
- **Frais de gas**: Les transactions sur blockchain co√ªtent des frais
- **Slippage**: Les prix peuvent changer entre la d√©tection et l'ex√©cution
- **Testez d'abord**: Utilisez des montants faibles pour tester

## üìû Support

Pour toute question ou probl√®me :
- Ouvrez une issue sur GitHub
- Consultez la documentation des DEX
- V√©rifiez les logs d'erreur

---

**D√©velopp√© avec ‚ù§Ô∏è pour la communaut√© DeFi**
